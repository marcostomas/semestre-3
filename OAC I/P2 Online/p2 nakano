1- float f1 não cabe num inteiro. Portanto, ele transforma no maior número inteiro possível

2- union reserva apenas uma região de memória. é semelhante a uma struct, porém todos os campos são acessíveis a partir de um único endereço.

// 0086726A
// 00000000 10000110 01110010 01101010
// 0 00000001 00001100111001001101010
// bin: 1.00001100111001001101010 * 2^(-126)
// dec: 1.05036664 * 2^(-126)
// = 1.234700052e-38


conversão de f11:
  0086726A
  00000000 10000110 01110010 01101010
  0 00000001 00001100111001001101010
  exp = 00000001 (-127) = -126
  significando = decimal(100001100111001001101010) / 2^23
    = 8811114 / 2^23
    = 1.05036664
  dec: +1.05036664 * 2^(-126)
    = +1.234700052e-38

conversão de f12:
  000D71D7
  00000000 00001101 01110001 11010111
  0 00000000 00011010111000111010111
  como o número é subnormal, o expoente é -126
  significando = decimal(00011010111000111010111) / 2^23
    = 881111 / 2^23
    = 0.105036616
  dec: +0.105036616 * 2^(-126)
    = +1.234699487e-39

conversão de f13:
  00000371
  00000000 00000000 00000011 01110001
  0 00000000 00000000000001101110001
  como o número é subnormal, o expoente é -126
  significando = decimal(00000000000001101110001) / 2^23
    = 881 / 2^23
    = 0.000105023
  dec: +0.000105023 * 2^(-126)
    = +1.234543947e-42

conversão de f14:
  00000001
  00000000 00000000 00000000 00000001
  0 00000000 00000000000000000000001
  como o número é subnormal, o expoente é -126
  significando = decimal(00000000000000000000001) / 2^23
    = 1 / 2^23
    = 0.000000119
  dec: +0.000000119 * 2^(-126)
    = +1.398838277e-45
